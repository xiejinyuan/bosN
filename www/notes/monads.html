<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="generator" content="pandoc" />
  <title>Monads and more</title>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode, table.sourceCode pre 
   { margin: 0; padding: 0; border: 0; vertical-align: baseline; border: none; }
td.lineNumbers { border-right: 1px solid #AAAAAA; text-align: right; color: #AAAAAA; padding-right: 5px; padding-left: 5px; }
td.sourceCode { padding-left: 5px; }
code.sourceCode span.kw { color: #007020; font-weight: bold; } 
code.sourceCode span.dt { color: #902000; }
code.sourceCode span.dv { color: #40a070; }
code.sourceCode span.bn { color: #40a070; }
code.sourceCode span.fl { color: #40a070; }
code.sourceCode span.ch { color: #4070a0; }
code.sourceCode span.st { color: #4070a0; }
code.sourceCode span.co { color: #60a0b0; font-style: italic; }
code.sourceCode span.ot { color: #007020; }
code.sourceCode span.al { color: red; font-weight: bold; }
code.sourceCode span.fu { color: #06287e; }
code.sourceCode span.re { }
code.sourceCode span.er { color: red; font-weight: bold; }
  </style>
</head>
<body>
<h1 class="title">Monads and more</h1>
<h1 id="remember-the-maybe-type">Remember the Maybe type</h1>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Maybe</span> a <span class="fu">=</span> <span class="kw">Nothing</span><br />             <span class="fu">|</span> <span class="kw">Just</span> a</code></pre>
<h1 id="we-know-that-maybe-is-a-functor">We know that Maybe is a functor</h1>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Maybe</span> a <span class="fu">=</span> <span class="kw">Nothing</span><br />             <span class="fu">|</span> <span class="kw">Just</span> a<br /><br /><span class="kw">class</span> <span class="kw">Functor</span> f <span class="kw">where</span><br /><span class="ot">    fmap </span><span class="ot">::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b<br /><br /><span class="kw">instance</span> <span class="kw">Functor</span> <span class="dt">Maybe</span> <span class="kw">where</span><br />    <span class="fu">fmap</span> _ <span class="kw">Nothing</span>  <span class="fu">=</span> <span class="kw">Nothing</span><br />    <span class="fu">fmap</span> f (<span class="kw">Just</span> a) <span class="fu">=</span> <span class="kw">Just</span> (f a)</code></pre>
<h1 id="what-does-fmap-actually-mean">What does fmap actually mean?</h1>
<p>We have a polymorphic type <code>f</code>, and <code>fmap</code> gives us the ability to:</p>
<ul>
<li><p>Liberate a pure value from the type constructor that refers to it</p></li>
<li><p>Call a function on it, which could return a result of a different type</p></li>
<li><p>Have the type constructor refer to the type of the result</p></li>
</ul>
<h1 id="so-whats-f">So what's f?</h1>
<p>That polymorphic type <code>f</code> was daunting to me when I was learning Haskell.</p>
<p>The easiest easy to <em>begin</em> to think of <code>f</code> is as a &quot;container&quot;.</p>
<p>Here is the most basic of containers:</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Container</span> a <span class="fu">=</span> <span class="dt">Container</span> a<br /><br /><span class="kw">instance</span> <span class="kw">Functor</span> <span class="dt">Container</span> <span class="kw">where</span><br />    <span class="fu">fmap</span> f (<span class="dt">Container</span> a) <span class="fu">=</span> <span class="dt">Container</span> (f a)</code></pre>
<p>We can't get any simpler than this, since (being a <code>newtype</code>) it doesn't have a runtime representation at all.</p>
<h1 id="more-containers">More containers</h1>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="kw">Functor</span> <span class="dt">Container</span> <span class="kw">where</span><br />    <span class="fu">fmap</span> f (<span class="dt">Container</span> a) <span class="fu">=</span> <span class="dt">Container</span> (f a)<br /><br /><span class="kw">instance</span> <span class="kw">Functor</span> <span class="dt">Maybe</span> <span class="kw">where</span><br />    <span class="fu">fmap</span> _ <span class="kw">Nothing</span>  <span class="fu">=</span> <span class="kw">Nothing</span><br />    <span class="fu">fmap</span> f (<span class="kw">Just</span> a) <span class="fu">=</span> <span class="kw">Just</span> (f a)<br /><br /><span class="kw">instance</span> <span class="kw">Functor</span> [] <span class="kw">where</span><br />    <span class="fu">fmap</span> <span class="fu">=</span> <span class="fu">map</span></code></pre>
<p>Having seen these instances, we can now state with some confidence:</p>
<ul>
<li><p>For a container type, <code>fmap</code> replaces every element of the container with the result of applying <code>f</code> to that element.</p></li>
<li><p>It leaves the <em>structure</em> of the container unchanged.</p></li>
</ul>
<p>In other words, <code>fmap</code> will not turn a <code>Just</code> into a <code>Nothing</code>, or a 3-element list into an empty list, or the like.</p>
<h1 id="is-that-it">Is that it?</h1>
<p>As useful as this intuitive picture is, it's actually not general enough.</p>
<p>We'd be making a mistake if we thought we had the whole story now, because the truth is far richer (and stranger).</p>
<h1 id="functions">Functions</h1>
<p>Let's poke about in <code>ghci</code>:</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="fu">&gt;&gt;</span> <span class="fu">:</span><span class="kw">type</span> <span class="fu">not</span><br /><span class="fu">not</span><span class="ot"> </span><span class="ot">::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></code></pre>
<p>Remember that the <code>-&gt;</code> symbol is not magic: it's just a type constructor.</p>
<p>Using a notational shortcut, we could rewrite the type above as:</p>
<pre class="sourceCode"><code class="sourceCode haskell">(<span class="ot">-&gt;</span>) <span class="dt">Bool</span> <span class="dt">Bool</span></code></pre>
<p>If we get rid of the concrete types and replace them with polymorphic placeholders, we can write a type signature like this:</p>
<pre class="sourceCode"><code class="sourceCode haskell">(<span class="ot">-&gt;</span>) a b</code></pre>
<h1 id="more-fun-with-functions">More fun with functions</h1>
<p>Okay, so we know that this is a function type:</p>
<pre class="sourceCode"><code class="sourceCode haskell">(<span class="ot">-&gt;</span>)</code></pre>
<p>And this is a function that accepts an argument of some type <code>a</code>, and gives a result of some other type <code>b</code>:</p>
<pre class="sourceCode"><code class="sourceCode haskell">(<span class="ot">-&gt;</span>) a b</code></pre>
<p>So then what's this?</p>
<pre class="sourceCode"><code class="sourceCode haskell">(<span class="ot">-&gt;</span>) a</code></pre>
<h1 id="isnt-that-suggestive">Isn't that suggestive?</h1>
<p>This type, being a function that accepts an argument of type <code>a</code>, is polymorphic. (Why?)</p>
<pre class="sourceCode"><code class="sourceCode haskell">((<span class="ot">-&gt;</span>) a)</code></pre>
<p>Which suggests that even though it's surely not a container type, we could write a <code>Functor</code> instance.</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="kw">Functor</span> ((<span class="ot">-&gt;</span>) a) <span class="kw">where</span><br />    <span class="fu">fmap</span> f <span class="co">{- ...what? -}</span></code></pre>
<h1 id="stop-hammer-time">Stop! Hammer time!</h1>
<p>On the whiteboard, let's puzzle through what the <code>Functor</code> instance ought to look like.</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="kw">Functor</span> ((<span class="ot">-&gt;</span>) a) <span class="kw">where</span><br />    <span class="fu">fmap</span> f <span class="co">{- ...what? -}</span></code></pre>
<h1 id="i-hope-you-havent-peeked-ahead">I hope you haven't peeked ahead!</h1>
<p>Because here's that definition we were scrawling on the whiteboard.</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="kw">Functor</span> ((<span class="ot">-&gt;</span>) a) <span class="kw">where</span><br />    <span class="fu">fmap</span> f g <span class="fu">=</span> \x <span class="ot">-&gt;</span> f (g x)</code></pre>
<p>Which we can simplify to:</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="kw">Functor</span> ((<span class="ot">-&gt;</span>) a) <span class="kw">where</span><br />    <span class="fu">fmap</span> f g <span class="fu">=</span> f <span class="fu">.</span> g</code></pre>
<p>And again:</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="kw">Functor</span> ((<span class="ot">-&gt;</span>) a) <span class="kw">where</span><br />    <span class="fu">fmap</span> <span class="fu">=</span> (<span class="fu">.</span>)</code></pre>
<h1 id="wow.-wow">Wow. Wow!</h1>
<p>Function application is somehow a functor?</p>
<p>I know, right!?</p>
<p>Let's play with that in <code>ghci</code> a bit.</p>
<h1 id="so-really-whats-a-functor">So really, what's a functor?</h1>
<p>A functor (in Haskell) is simply a pair of things:</p>
<ul>
<li><p>A polymorphic type constructor</p></li>
<li><p>A definition for <code>fmap</code></p></li>
</ul>
<p>The instance has to obey two simple laws:</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="fu">fmap</span> <span class="fu">id</span>      <span class="fu">==</span> <span class="fu">id</span><br /><span class="fu">fmap</span> (f <span class="fu">.</span> g) <span class="fu">==</span> <span class="fu">fmap</span> f <span class="fu">.</span> <span class="fu">fmap</span> g</code></pre>
<p>As usual with laws, it's up to you as a coder to satisfy the laws with your <code>Functor</code> instances.</p>
<h1 id="the-next-step">The next step</h1>
<p>In the <code>Control.Applicative</code> package we'll find another extremely useful typeclass:</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">class</span> <span class="kw">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Applicative</span> f <span class="kw">where</span><br /><br /><span class="ot">    pure </span><span class="ot">::</span> a <span class="ot">-&gt;</span> f a<br /><br /><span class="ot">    (&lt;*&gt;) </span><span class="ot">::</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</code></pre>
<p>The <code>Applicative</code> class builds on functors to add two very useful new behaviours.</p>
<ul>
<li><p>The <code>pure</code> operator lifts a normal value into the type.</p></li>
<li><p>The <code>&lt;*&gt;</code> operator sequences function application through the type.</p></li>
</ul>
<h1 id="lifting-again">Lifting again</h1>
<p>If those definitions feel slippery, remember the signature for <code>fmap</code>:</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="fu">fmap</span><span class="ot"> </span><span class="ot">::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</code></pre>
<p>The only difference between <code>fmap</code> and <code>&lt;*&gt;</code> is that <code>&lt;*&gt;</code> starts off with the function wrapped in the type <code>f</code>.</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">(&lt;*&gt;) </span><span class="ot">::</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</code></pre>
<p>This is easiest to follow with a concrete example.</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Maybe</span> <span class="kw">where</span><br />    pure <span class="fu">=</span> <span class="kw">Just</span><br /><br />    <span class="kw">Just</span> f <span class="fu">&lt;*&gt;</span> <span class="kw">Just</span> a <span class="fu">=</span> <span class="kw">Just</span> (f a)<br />    _      <span class="fu">&lt;*&gt;</span> _      <span class="fu">=</span> <span class="kw">Nothing</span></code></pre>
<h1 id="thinking-about-constraints">Thinking about constraints</h1>
<p>Which of these questions is easier to answer?</p>
<ul>
<li><p>&quot;I'm thinking of a number. It's less than 5.&quot;</p></li>
<li><p>&quot;I'm thinking of a number. It's less than 5. It's greater than zero.&quot;</p></li>
</ul>
<p>By adding more information, we've constrained the possible numbers available to be guessed.</p>
<p>We can loosely carry this line of thinking over to typeclasses:</p>
<ul>
<li><p>The more functions a typeclass has, the more constraints there are on the types that can possibly implement it.</p></li>
<li><p>The more laws an instance must satisfy, the smaller the number of types that can satisfy them.</p></li>
</ul>
<h1 id="function-application-as-an-applicative-functor">Function application as an applicative functor</h1>
<p>To keep those brains nice and groovy, let's look at how function application lives as an <code>Applicative</code>.</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Applicative</span> ((<span class="ot">-&gt;</span>) a) <span class="kw">where</span><br />    pure _  <span class="fu">=</span> \x <span class="ot">-&gt;</span> x<br /><br />    f <span class="fu">&lt;*&gt;</span> g <span class="fu">=</span> \x <span class="ot">-&gt;</span> f x (g x)</code></pre>
<h1 id="functor-vs-applicative">Functor vs Applicative</h1>
<p>The <code>Functor</code> class has one method and two laws.</p>
<p>The <code>Applicative</code> class adds two methods and four laws (the laws are simple and intuitive, but I'm not going to describe them).</p>
<p>By appeal to my prior handwaving, the added richness of <code>Applicative</code> comes at a cost:</p>
<ul>
<li>There exist many more types that we can turn into functors than into applicatives.</li>
</ul>
<p>That richness is appealing though: we'll take it when we can. (But I'm not going to explain why just yet.)</p>
<h1 id="functor-vs-applicative-revisited">Functor vs Applicative, revisited</h1>
<p>An applicative is once again a triple of things:</p>
<ul>
<li><p>A polymorphic type constructor that we know to be a functor</p></li>
<li><p>A definition for <code>pure</code></p></li>
<li><p>A definition for <code>(&lt;*&gt;)</code></p></li>
</ul>
<p>And the definitions have to satisfy the aforementioned four laws (which you can <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Applicative.html#t:Applicative">look up for yourself</a>).</p>
<h1 id="and-on-to-monads">And on to monads</h1>
<p>Monads represent another step up the ladder of richness from applicative functors.</p>
<p>This is, of course, thanks to the bind operator.</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">(&gt;&gt;=) </span><span class="ot">::</span> <span class="kw">Monad</span> m <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b</code></pre>
<p>We've already used this operator aplenty, but even so, we lacked the background to discuss why it matters.</p>
<h1 id="what-we-gain-with-a-bind-operator">What we gain with a bind operator</h1>
<p>Here's a piece of code that we simply can't express using only the <code>Functor</code> or <code>Applicative</code> machinery:</p>
<pre class="sourceCode"><code class="sourceCode haskell">oddEnough act <span class="fu">=</span> <span class="kw">do</span><br />  v <span class="ot">&lt;-</span> act<br />  <span class="kw">if</span> <span class="fu">odd</span> v<br />    <span class="kw">then</span> <span class="fu">fail</span> <span class="st">&quot;too odd!&quot;</span><br />    <span class="kw">else</span> <span class="fu">return</span> v</code></pre>
<p>Neither <code>fmap</code> nor <code>&lt;*&gt;</code> lets us &quot;change the shape&quot; of the outcome of a series of operations, but <code>&gt;&gt;=</code> <em>does</em>.</p>
<p>To make that more concrete:</p>
<ul>
<li><p>Any number of compositions of <code>fmap</code> over a <em>k</em>-element list will always give back a <em>k</em>-element list.</p></li>
<li><p>The <code>&gt;&gt;=</code> operator lets us inspect an intermediate result and thus change what the final result will be, and do so without knowing how the <code>Monad</code> instance is constructed.</p></li>
</ul>
<h1 id="some-examples">Some examples</h1>
<p>Here's a standard function that takes a predicate expression and an action, and executes the action only if the predicate succeeds:</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">when </span><span class="ot">::</span> (<span class="kw">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> m () <span class="ot">-&gt;</span> m ()<br />when p act <span class="fu">=</span> <span class="kw">if</span> p <span class="kw">then</span> act <span class="kw">else</span> <span class="fu">return</span> ()</code></pre>
<p>Notice that we've defined a very handy control flow function that will work in <em>all</em> monads.</p>
<p>Suppose we want to perform an action that returns a success/fail indication, and use that result to determine whether to perform a <em>second</em> action.</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">whenM </span><span class="ot">::</span> (<span class="kw">Monad</span> m) <span class="ot">=&gt;</span> m <span class="dt">Bool</span> <span class="ot">-&gt;</span> m () <span class="ot">-&gt;</span> m ()</code></pre>
<p>Let's write out a body for this function.</p>
<h1 id="tantalizing-hints">Tantalizing hints</h1>
<p>Here's a function from <code>Control.Monad</code> that we've seen before:</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">liftM </span><span class="ot">::</span> <span class="kw">Monad</span> m   <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> m a <span class="ot">-&gt;</span> m r</code></pre>
<p>It bears a striking resemblance to this:</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="fu">fmap</span><span class="ot">  </span><span class="ot">::</span> <span class="kw">Functor</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</code></pre>
<p>And here's a function we just met:</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">(&lt;*&gt;) </span><span class="ot">::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</code></pre>
<p>Which looks very similar to this <code>Control.Monad</code> combinator:</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">ap    </span><span class="ot">::</span> <span class="kw">Monad</span> m       <span class="ot">=&gt;</span> m (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> m a <span class="ot">-&gt;</span> m b</code></pre>
<h1 id="a-little-history">A little history</h1>
<p>We've seen that <code>Applicative</code> is defined to be a subclass of <code>Functor</code>:</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">class</span> <span class="kw">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Applicative</span> f <span class="co">{- ... -}</span></code></pre>
<p>Shouldn't one of these hold, too?</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">class</span> <span class="kw">Functor</span> m <span class="ot">=&gt;</span> <span class="kw">Monad</span> m <span class="co">{- ... -}</span><br /><br /><span class="kw">class</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> <span class="kw">Monad</span> m <span class="co">{- ... -}</span></code></pre>
<p>The answer is basically &quot;yes in principle, but for historical reasons, no&quot;.</p>
<p>Monads and functors were introduced to Haskell around the same time, and I'm not sure the possible relationship between them was recognized at the time.</p>
<p>Applicative functors <a href="http://www.soi.city.ac.uk/~ross/papers/Applicative.html">arrived on the scene much later</a>. By the time a possible resolution to the tangle was identified, there was too much code &quot;in the wild&quot; to change things.</p>
</body>
</html>
